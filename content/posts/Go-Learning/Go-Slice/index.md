---
title: "Go Slice"
date: 2021-03-24T15:54:09+08:00
aliases: []
categories:
 - Programming Language
tags: 
 - Golang
 - Slice
description: 
featured_image:
draft: false
author: 1uvu
---

**切片** (*Slice*)，是一种十分常用的数据结构，它几乎是每一种编程语言的核心，集中体现了语言本身的设计理念。这一部分在切片基础概念的基础上深入探讨一下关于 Golang 中切片的**基本用法**、**底层实现**和**注意事项**，并不会太涉及基本的语法。

## 基本使用

首先应该了解，切片是作为固定大小的数组的指针的形式存在的，它是一种**新的数据结构**，描述了固定大小的数组的一部分，而不是数据，不应该把数组的切片与数组本身混淆起来。

切片的索引是一个半开区间，在 Go 中，不允许负索引和逆索引的存在。

对于切片的属性，需要知道它拥有**长度** (*len*)和**容量 **(*cap*)，长度是切片**包含指向的**元素的个数，容量是它从指向的第一个元素开始，到**底层数组末尾**元素的个数。

可以使用对应的函数对切片执行追加、遍历等操作。

## 底层实现

### 长度和容量的关系

下图是切片的底层数据结构，其中 ptr 是一个**指向数组某一位置**的**指针**。

![img](res/index/go-slices-usage-and-internals_slice-struct.png)

一个长度为 5 的 byte 数组的切片 s 是这样的：

![img](res/index/go-slices-usage-and-internals_slice-1.png)

而如果将切片更新：s = s[2:4]，就变成了这样：

![img](res/index/go-slices-usage-and-internals_slice-2.png)

由于不允许存在负索引，所以，数组的前两个元素就再无法通过切片访问到了，此时切片的容量从 5 缩小为 3。

所以，**容量其实是代表了长度的最大限制**。

### 切片的生长

append 函数会将传入的元素放入切片所指向底层数组的最后，并在必要时增长数组的长度，切片的容量也随之增加。但是，append 函数返回的切片并**不是原来切片的副本**，这就保证了操作切片具有与操作底层数组相同的性能。

copy 函数可以完成切片到切片的数据拷贝，只会拷贝较少长度的那些数据，会覆盖掉原来位置的数据。

## 注意事项

【todo】