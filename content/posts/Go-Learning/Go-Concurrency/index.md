---
title: "Go Concurrency"
date: 2021-03-27T16:29:53+08:00
aliases: []
categories:
 - Programming Language
tags: 
 - Golang
 - Concurrency
description: 
featured_image:
draft: false
author: 1uvu
---

本文基于 tour.go-zh.org、MIT 6.824 Lecture 2、[Go 语言并发编程与 Context | Go 语言设计与实现 (draveness.me)](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/) 及 Efficient Go 中对应的部分内容。

## 目录

-   并发的本质
    -   io复用-并发
    -   cpu复用-并行
-   go 中的并发编程
    -   go程
    -   调度器
    -   基本原语
    -   扩展原语
    -   定时器
    -   channel
-   并发的挑战
    -   互斥与同步
        -   共享数据的竞争：互斥问题
        -   线程间的协调：同步问题
    -   死锁与恢复
        -   死锁的几种常见情况
        -   避免死锁的几种方式
        -   恢复死锁的几种方式
-   使用通信来共享内存
    -   context
    -   channel
    -   rpc
-   并发的实例
    -   Web Crawler
    -   KV
    -   Voting



## 并发编程

并发编程是程序设计中十分重要的一个部分，是程序员划分等级的重要参考条件。并发编程主要涉及两个方面的目标，一是 IO 复用，二是 CPU 复用。

通常情况下我们所谈及的其实都是 IO 复用。一个进程在其本身的地址空间内创建多个共享公用资源的线程以复用进程资源，多线程允许一个程序可以在自己的执行周期内完成更多的任务。每个线程均是串行执行的，且每个线程均拥有自己的线程状态，就像进程一样，包括程序计数器、寄存器、栈。

IO 复用的本质是，在一个线程占用内存等互斥资源的同时，其他线程可以执行另外的无需占据资源的任务，这极大改善了由于资源占用从而阻塞程序所导致的 IO 利用率底下的问题。

而 CPU 复用，即利用现代处理器提供的多个核心，达到真正意义上的并行执行。

## 单核心的并发

### Go 程

在 Go 中，并发的单位称为 goroutine，Go 程，可以使用 go func(){}() 或是提供具体的函数字面来启动一个 Go 程来异步执行这个函数。

它是非常轻量级的，所有消耗几乎只有栈空间的分配，栈最开始是很小的，仅在需要时才会随着堆空间的分配和释放而变化。

注意，前文提到过，Go 的函数字面都是闭包，而由于 Go 程的使用有时会导致闭包的延迟绑定。

### 并发的挑战

同一个程序的 Go 程在相同的地址空间中执行，所以必须考虑下面这些问题：

- 共享数据。要确保访问互斥资源的原子性，需要对于代码中涉及共享数据的变量和处理逻辑进行严格地控制。Go 的 sync 标准库提供了 sync.Mutex (互斥锁)来解决这个问题。

- 线程间的协调。如在生产者和消费者的实例中，生产者需要唤醒消费者，消费者也要确定在何时停止阻塞或是直接放弃执行。Go 的 sync 标准库中也提供了 sync.Cond (条件变量)、sync.WaitGroup (等待队列) 及 channels (管道通信) 数据结构来解决这种问题。

- 死锁。以 channel 为例，有如下三种会触发死锁的常见情况：

  - 同一个 Go 程中，使用同一个 chan 来读写；
  - chan 的赋值操作先于用于读 chan 的 Go 程创建；
  - 多个 Go 程和多个 chan 发生环路等待。
  - channel、读写锁和互斥锁的交叉混用可能导致未知的死锁。如果必须混用，则推荐条件变量。

  可以采取周期性的锁检查或是基于 RPC、channel 通信的方式来解决。

### 通过通信来共享内存

上面提到了 Go 中解决并发编程存在问题的各种方式。在并发编程中，为实现对共享变量的正确访问和修改需要十分精确的控制，否则程序可能会出现未知的行为甚至会出现死锁，这其实是很困难的。

Go 中，Go 程被设计为从不会主动共享，在任意时刻，同时只会有一个 Go 程能够访问共享数据，这才源头设计上就杜绝了数据竞争的发生。也就是说，会导致数据竞争这种异常行为发生的只有不成熟的程序员 (在编译程序时可以加上 -race tag 来检查代码中潜在的可能导致数据竞争的逻辑)。

在文章 Effective Go 中提出了一个口号：

> 不要通过共享内存来通信，而应通过通信来共享内存。

在 Go 中，我们无需花费精力设计代码实现确保通信过程的同步，通信本身就是同步的，因此，我们也无需考虑其他同步了。

### 管道 (Channel)

Go 中的 Channel是一种特殊的数据类型，